<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>ÈÄóÁå´Â∞èÁêÉ</title>
    <style>
        /* --- ÂÖ®Â±ÄÂ≠ó‰Ωì‰∏éÈáçÁΩÆ --- */
        body {
            margin: 0; overflow: hidden; background-color: #fdfbf7;
            touch-action: none; user-select: none; -webkit-user-select: none;
            font-family: "Chalkboard SE", "Comic Sans MS", "Marker Felt", sans-serif;
            transition: background-color 0.4s ease;
        }
        canvas { display: block; }
        
        /* --- UI Â±Ç --- */
        #ui-layer {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            pointer-events: none; z-index: 10;
        }

        /* ÊâãÁªòÁõíÂ≠ê */
        .doodle-box {
            background: #fff; border: 3px solid #222;
            border-radius: 2px 255px 3px 25px / 255px 5px 225px 3px;
            box-shadow: 4px 4px 0px 0px #222; color: #222;
            transition: all 0.1s ease; pointer-events: auto; cursor: pointer;
        }
        .doodle-box:active {
            transform: translate(2px, 2px); box-shadow: 2px 2px 0px 0px #222; background-color: #f0f0f0;
        }
        
        /* È°∂ÈÉ®ÊåâÈíÆ */
        .top-btn {
            position: absolute; top: 15px; width: 50px; height: 50px;
            font-size: 24px; display: flex; align-items: center; justify-content: center; padding: 0;
        }
        #btn-settings { left: 15px; border-radius: 50% 40% 60% 40% / 40% 60% 50% 60%; }
        #btn-lock { right: 15px; background-color: #fff3cd; border-radius: 40% 60% 40% 50% / 60% 40% 60% 50%; }

        #hint {
            position: absolute; top: 50%; left: 50%;
            transform: translate(-50%, -50%) rotate(-2deg);
            color: #aaa; font-size: 24px; font-weight: bold;
            pointer-events: none; text-align: center; width: 80%;
            text-shadow: 2px 2px 0px #fff;
        }

        /* ËÆæÁΩÆÈù¢Êùø */
        #settings-panel {
            pointer-events: auto; position: absolute; top: 50%; left: 50%;
            transform: translate(-50%, -50%); padding: 25px; width: 300px;
            display: none; flex-direction: column; gap: 15px;
            border-radius: 5px 25px 3px 25px / 25px 3px 25px 5px;
            background-image: radial-gradient(#ddd 10%, transparent 10%), radial-gradient(#ddd 10%, transparent 10%);
            background-color: #fff; background-position: 0 0, 10px 10px; background-size: 20px 20px;
            box-shadow: 6px 6px 0px 0px #222; border: 3px solid #222;
            max-height: 85vh; overflow-y: auto;
        }
        .panel-header {
            border-bottom: 3px dashed #222; padding-bottom: 10px; margin-bottom: 5px; text-align: center;
        }
        .panel-header h3 { margin: 0; font-size: 22px; letter-spacing: 1px; transform: rotate(-1deg); }
        
        .control-group { display: flex; flex-direction: column; gap: 8px; }
        .control-group label { font-size: 16px; font-weight: bold; display: flex; justify-content: space-between; align-items: center; }

        /* ÂºÄÂÖ≥ */
        .toggle-switch { position: relative; display: inline-block; width: 50px; height: 28px; }
        .toggle-switch input { opacity: 0; width: 0; height: 0; }
        .slider {
            position: absolute; cursor: pointer; top: 0; left: 0; right: 0; bottom: 0;
            background-color: #ccc; transition: .2s; border: 2px solid #222;
            border-radius: 255px 15px 225px 15px / 15px 225px 15px 255px;
        }
        .slider:before {
            position: absolute; content: ""; height: 18px; width: 18px; left: 3px; bottom: 3px;
            background-color: white; border: 2px solid #222; transition: .2s; border-radius: 50%;
        }
        input:checked + .slider { background-color: #4CAF50; }
        input:checked + .slider:before { transform: translateX(22px); }

        /* ÊªëÂä®Êù° */
        input[type=range] { -webkit-appearance: none; width: 100%; background: transparent; margin: 10px 0; }
        input[type=range]:focus { outline: none; }
        input[type=range]::-webkit-slider-runnable-track {
            width: 100%; height: 8px; background: #fff; border: 2px solid #222; border-radius: 10px; box-shadow: 2px 2px 0 #222; cursor: pointer;
        }
        input[type=range]::-webkit-slider-thumb {
            -webkit-appearance: none; height: 24px; width: 24px; border-radius: 50%; background: #fff; border: 3px solid #222; margin-top: -10px; box-shadow: 2px 2px 0 #000; cursor: pointer; transition: transform 0.1s;
        }
        input[type=range]::-webkit-slider-thumb:active { background: #222; transform: scale(1.1); }

        /* ‰∏ªÈ¢ò */
        .theme-grid { display: grid; grid-template-columns: repeat(3, 1fr); gap: 12px; margin-top: 5px; }
        .theme-btn {
            height: 45px; border: 2px solid #222; border-radius: 12px 5px 15px 3px / 5px 15px 3px 12px; position: relative; cursor: pointer; box-shadow: 2px 2px 0 rgba(0,0,0,0.1); transition: transform 0.1s;
        }
        .theme-btn:active { transform: scale(0.95); }
        .theme-btn.active { border: 3px solid #222; box-shadow: 3px 3px 0 #222; transform: translate(-1px, -1px) rotate(2deg); z-index: 2; }
        .theme-btn.active::after {
            content: '‚úî'; position: absolute; right: -5px; top: -10px; font-size: 14px; color: #222; background: #fff; border: 2px solid #222; border-radius: 50%; width: 18px; height: 18px; display: flex; align-items: center; justify-content: center;
        }
        .theme-preview-ball {
            width: 16px; height: 16px; border: 2px solid rgba(0,0,0,0.2); border-radius: 50%; position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
        }

        .action-btns { display: flex; margin-top: 10px; }
        #btn-close { 
            background-color: #f8d7da; width: 100%; border-radius: 15px 225px 15px 255px / 255px 15px 225px 15px;
            padding: 12px; font-size: 16px; font-weight: bold; cursor: pointer; border: 2px solid #222; box-shadow: 3px 3px 0 #222;
        }
        #btn-close:active { transform: translate(2px, 2px); box-shadow: 1px 1px 0 #222; }

        #unlock-container {
            position: absolute; top: 15px; right: 15px; pointer-events: auto; display: none;
            flex-direction: column; align-items: flex-end; z-index: 20;
        }
        #btn-unlock-trigger {
            background: rgba(255, 255, 255, 0.6); border: 3px dashed #888; color: #555; font-size: 14px; font-weight: bold; padding: 10px 15px; border-radius: 255px 15px 225px 15px / 15px 225px 15px 255px; user-select: none; cursor: pointer;
        }
        #unlock-progress-container {
            width: 100%; height: 8px; border: 2px solid #555; margin-top: 5px; background: #fff; border-radius: 5px; overflow: hidden; display: none;
        }
        #unlock-progress { height: 100%; background: #4CAF50; width: 0%; }
    </style>
</head>
<body>

    <div id="hint">‚ú® ÁÇπÂáªÂ±èÂπïÂºÄÂßã ‚ú®</div>
    <canvas id="gameCanvas"></canvas>

    <div id="ui-layer">
        <div id="btn-settings" class="top-btn doodle-box">‚öôÔ∏è</div>
        <div id="btn-lock" class="top-btn doodle-box">üîí</div>

        <div id="unlock-container">
            <div id="btn-unlock-trigger">ÈïøÊåâ 2s Ëß£ÈîÅ</div>
            <div id="unlock-progress-container">
                <div id="unlock-progress"></div>
            </div>
        </div>
        
        <div id="settings-panel">
            <div class="panel-header"><h3>üé® ÈÄóÁå´ÈÖçÁΩÆ</h3></div>
            
            <div class="control-group">
                <label>ÈÖçËâ≤‰∏ªÈ¢ò</label>
                <div class="theme-grid" id="theme-container"></div>
            </div>

            <div class="control-group">
                <label>üîä Ê≤ôÊ≤ôÂ£∞Èü≥Êïà
                    <label class="toggle-switch">
                        <input type="checkbox" id="chk-sound" checked>
                        <span class="slider"></span>
                    </label>
                </label>
            </div>

            <div class="control-group">
                <label>Â•îË∑ëÈÄüÂ∫¶ <span id="val-speed">1.0x</span></label>
                <input type="range" id="range-speed" min="0.5" max="2.5" step="0.1" value="1.0">
            </div>
            
            <div class="control-group">
                <label>Â∞èÁêÉÂ§ßÂ∞è <span id="val-size">1.0x</span></label>
                <input type="range" id="range-size" min="0.5" max="2.0" step="0.1" value="1.0">
            </div>
            
            <div class="control-group">
                <label>Êå£ÊâéÊó∂Èïø <span id="val-struggle">1.5s</span></label>
                <input type="range" id="range-struggle" min="0.5" max="3.0" step="0.1" value="1.5">
            </div>

            <div class="action-btns">
                <button id="btn-close">‚úñ ÂÖ≥Èó≠ËèúÂçï</button>
            </div>
        </div>
    </div>

    <script>
        // ---------------- Ê≤ôÂ≠êÊëáÊôÉÈü≥ÊïàÂºïÊìé ----------------
        let audioCtx = null;
        let sandGain = null;
        let isAudioInitialized = false;

        function initAudioSystem() {
            if (isAudioInitialized) return;
            try {
                const AudioContext = window.AudioContext || window.webkitAudioContext;
                audioCtx = new AudioContext();
                
                // 1. ÂàõÂª∫ÁôΩÂô™Èü≥ (Ê≤ôÂ≠êÁöÑÊ∫êÂ§¥)
                const bufferSize = audioCtx.sampleRate * 2; 
                const buffer = audioCtx.createBuffer(1, bufferSize, audioCtx.sampleRate);
                const data = buffer.getChannelData(0);
                for (let i = 0; i < bufferSize; i++) {
                    data[i] = Math.random() * 2 - 1;
                }
                
                const noiseSource = audioCtx.createBufferSource();
                noiseSource.buffer = buffer;
                noiseSource.loop = true;

                // 2. Êª§Ê≥¢Âô®ÔºöÂ∏¶ÈÄö (Bandpass)
                // È¢ëÁéáËÆæÂú® 4000HzÔºåQÂÄºËÆæÂú® 1.0ÔºåËøáÊª§Êéâ‰ΩéÈ¢ëÂíåË∂ÖÈ´òÈ¢ë
                // ËøôÊ†∑Âê¨Ëµ∑Êù•ÊâçÊúâ"Ê≤ôÂ≠ê"ÁöÑË¥®ÊÑüÔºåËÄå‰∏çÊòØ"ÁîµÊµÅÂ£∞"
                const sandFilter = audioCtx.createBiquadFilter();
                sandFilter.type = 'bandpass';
                sandFilter.frequency.value = 4000; 
                sandFilter.Q.value = 0.8; 

                // 3. Èü≥ÈáèÊéßÂà∂
                sandGain = audioCtx.createGain();
                sandGain.gain.value = 0; // ÂàùÂßãÈùôÈü≥

                // ËøûÊé•
                noiseSource.connect(sandFilter);
                sandFilter.connect(sandGain);
                sandGain.connect(audioCtx.destination);

                noiseSource.start(0);
                isAudioInitialized = true;

            } catch (e) {
                console.warn("Web Audio API error", e);
            }
        }

        // Êå£ÊâéÈü≥Êïà (‰øùÊåÅ‰∏çÂèòÔºöÂïæÂïæÂ£∞)
        function playSqueak() {
            if (!isAudioInitialized || !audioCtx) return;
            if (audioCtx.state === 'suspended') audioCtx.resume();

            const t = audioCtx.currentTime;
            const osc = audioCtx.createOscillator();
            const gain = audioCtx.createGain();
            
            osc.type = 'sine'; 
            osc.frequency.setValueAtTime(600, t);
            osc.frequency.exponentialRampToValueAtTime(1200, t + 0.1);
            osc.frequency.exponentialRampToValueAtTime(400, t + 0.2);

            gain.gain.setValueAtTime(0, t);
            gain.gain.linearRampToValueAtTime(0.6, t + 0.05);
            gain.gain.exponentialRampToValueAtTime(0.01, t + 0.2);

            osc.connect(gain);
            gain.connect(audioCtx.destination);
            osc.start(t);
            osc.stop(t + 0.25);
        }

        // Êõ¥Êñ∞Ê≤ôÂ≠êÂ£∞Èü≥
        function updateRunningSound() {
            if (!isAudioInitialized || !sandGain || !config.enableRunningSound) {
                if (sandGain) sandGain.gain.setTargetAtTime(0, audioCtx.currentTime, 0.1);
                return;
            }
            if (audioCtx.state === 'suspended') audioCtx.resume();

            const isMoving = ball.state === 'running' || ball.state === 'escaping';
            
            if (isMoving) {
                // ‰ΩøÁî® LFO (‰ΩéÈ¢ëÊåØËç°) Ê®°ÊãüÊëáÊôÉÁöÑËäÇÂ•è
                // "Ê≤ô-Ê≤ô-Ê≤ô-Ê≤ô" ÁöÑÊïàÊûú
                
                // Ëé∑ÂèñÂΩìÂâçÊó∂Èó¥ÔºåÂà∂ÈÄ†ËäÇÂ•è
                const time = Date.now() / 1000;
                
                // ÊëáÊôÉÈÄüÂ∫¶ÔºöÈöèÂ∞èÁêÉÈÄüÂ∫¶ÂèòÂø´ (8Hz - 16Hz)
                const shakeSpeed = 8 + (config.speedMult * 6); 
                
                // Âà∂ÈÄ†ËÑâÂÜ≤Ê≥¢ÂΩ¢ÔºöMath.sin ËæìÂá∫ -1 Âà∞ 1ÔºåÊàë‰ª¨ÂèñÁªùÂØπÂÄºÊàñËÄÖÂè™ÂèñÊ≠£ÂçäËΩ¥
                // Math.sin(x) > 0 ? 1 : 0 ËøôÁßçÊòØÊñπÊ≥¢ÔºåÂ§™Á°¨
                // ‰ΩøÁî® sine ÁöÑÂπ≥ÊñπÂèØ‰ª•ÂæóÂà∞ÂúÜÊ∂¶ÁöÑËÑâÂÜ≤
                const rhythm = Math.pow(Math.sin(time * shakeSpeed * Math.PI), 4);

                // Âü∫Á°ÄÈü≥Èáè (Ê≤ôÂ≠êÂ£∞‰∏çÈúÄË¶ÅÂ§™Â§ßÔºåÈ´òÈ¢ëÂæàÊòéÊòæ)
                const maxVol = 0.2; 
                
                // ÊúÄÁªàÈü≥Èáè = ËäÇÂ•è * ÊúÄÂ§ßÈü≥Èáè
                const targetVol = rhythm * maxVol;
                
                // Âø´ÈÄüÂìçÂ∫î
                sandGain.gain.setTargetAtTime(targetVol, audioCtx.currentTime, 0.05);

            } else {
                sandGain.gain.setTargetAtTime(0, audioCtx.currentTime, 0.1);
            }
        }

        // ---------------- Ê∏∏ÊàèÈÄªËæë ----------------
        const THEMES = [
            { name: 'ÁªèÂÖ∏Á±≥ÁôΩ', bg: '#fdfbf7', ball: '#111111' },
            { name: 'Êä§ÁúºÊöóÂ§ú', bg: '#2c3e50', ball: '#ecf0f1' },
            { name: 'Ê∏ÖÊñ∞ËçâÂú∞', bg: '#e8f5e9', ball: '#1b5e20' },
            { name: 'È´ò‰∫ÆÁ∫¢ÁêÉ', bg: '#ffffff', ball: '#d32f2f' },
            { name: 'Ê¥ªÂäõÊ©ô',   bg: '#fff3e0', ball: '#e65100' },
            { name: 'Ê∑±ÈÇÉÁ¥´',   bg: '#f3e5f5', ball: '#4a148c' }
        ];

        const config = {
            speedMult: 1.0,
            sizeMult: 1.0,
            struggleTime: 1.5,
            currentThemeIdx: 0,
            ballColor: THEMES[0].ball,
            bgColor: THEMES[0].bg,
            baseRadius: 25,
            baseHitRadius: 100,
            isLocked: false,
            enableRunningSound: true
        };

        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const hint = document.getElementById('hint');
        let width, height;
        
        const ball = {
            x: 0, y: 0, radius: 25, angle: 0, tailAngle: 0,
            blinkTimer: 0, isBlinking: false,
            state: 'running', stateTimer: 0,
            targetX: 0, targetY: 0
        };

        function init() {
            resize();
            window.addEventListener('resize', resize);
            ball.x = width / 2; ball.y = height / 2;
            pickNewTarget();
            
            document.addEventListener('mousedown', handleGlobalInteract, {once:true});
            document.addEventListener('touchstart', handleGlobalInteract, {once:true});

            canvas.addEventListener('mousedown', handleInput);
            canvas.addEventListener('touchstart', handleInput, {passive: false});
            initThemes();
            document.body.style.backgroundColor = config.bgColor;
            requestAnimationFrame(loop);
        }

        function handleGlobalInteract() { initAudioSystem(); }

        function initThemes() {
            const container = document.getElementById('theme-container');
            THEMES.forEach((theme, index) => {
                const btn = document.createElement('div');
                btn.className = 'theme-btn';
                if (index === 0) btn.classList.add('active');
                btn.style.backgroundColor = theme.bg;
                btn.title = theme.name;
                const ballPreview = document.createElement('div');
                ballPreview.className = 'theme-preview-ball';
                ballPreview.style.backgroundColor = theme.ball;
                btn.appendChild(ballPreview);
                btn.onclick = () => {
                    config.currentThemeIdx = index;
                    config.bgColor = theme.bg;
                    config.ballColor = theme.ball;
                    document.body.style.backgroundColor = config.bgColor;
                    document.querySelectorAll('.theme-btn').forEach(b => b.classList.remove('active'));
                    btn.classList.add('active');
                };
                container.appendChild(btn);
            });
        }

        function resize() {
            width = window.innerWidth; height = window.innerHeight;
            canvas.width = width; canvas.height = height;
        }

        function handleInput(e) {
            initAudioSystem();
            if (hint) hint.style.display = 'none';
            let ex = e.clientX, ey = e.clientY;
            if (e.changedTouches && e.changedTouches.length > 0) {
                ex = e.changedTouches[0].clientX; ey = e.changedTouches[0].clientY;
                e.preventDefault(); 
            }
            const dx = ex - ball.x, dy = ey - ball.y;
            const dist = Math.sqrt(dx*dx + dy*dy);
            const hitR = config.baseHitRadius * config.sizeMult;
            if (dist < hitR && ball.state !== 'hiding' && ball.state !== 'escaping') catchBall();
        }

        function catchBall() {
            if (ball.state === 'caught') return;
            ball.state = 'caught';
            ball.stateTimer = config.struggleTime * 60;
            playSqueak();
            setTimeout(() => { if(ball.state==='caught') playSqueak() }, 250);
            if (config.struggleTime > 1.0) setTimeout(() => { if(ball.state==='caught') playSqueak() }, 600);
        }

        function updateBehavior() {
            ball.stateTimer--;
            ball.radius = config.baseRadius * config.sizeMult;

            if (ball.state === 'running') {
                const dx = ball.targetX - ball.x;
                const dy = ball.targetY - ball.y;
                const dist = Math.sqrt(dx*dx + dy*dy);
                const baseSpeed = 10 + Math.random() * 3;
                const currentSpeed = baseSpeed * config.speedMult;

                if (dist <= currentSpeed * 1.2) { 
                    ball.x = ball.targetX; ball.y = ball.targetY;
                    if (Math.random() < 0.35) goOffScreen(); 
                    else { ball.state = 'idle'; ball.stateTimer = 20 + Math.random() * 50; }
                    return; 
                }
                const desiredAngle = Math.atan2(dy, dx);
                let turnFactor = 0.15; 
                if (dist < 200) turnFactor = 0.3;
                if (dist < 80) turnFactor = 0.8;
                turnFactor *= Math.max(1, config.speedMult); 
                turnFactor = Math.min(turnFactor, 1.0);
                ball.angle = lerpAngle(ball.angle, desiredAngle, turnFactor);
                ball.x += Math.cos(ball.angle) * currentSpeed;
                ball.y += Math.sin(ball.angle) * currentSpeed;
            } 
            else if (ball.state === 'idle') {
                if (ball.stateTimer <= 0) { ball.state = 'running'; pickNewTarget(); }
            }
            else if (ball.state === 'going_hide') {
                const speed = 14 * config.speedMult;
                ball.x += Math.cos(ball.angle) * speed;
                ball.y += Math.sin(ball.angle) * speed;
                if (ball.x < -200 || ball.x > width + 200 || ball.y < -200 || ball.y > height + 200) {
                    ball.state = 'hiding'; ball.stateTimer = 50 + Math.random() * 100;
                }
            }
            else if (ball.state === 'hiding') {
                if (ball.stateTimer <= 0) preparePeek();
            }
            else if (ball.state === 'peeking') {
                const dx = ball.targetX - ball.x;
                const dy = ball.targetY - ball.y;
                ball.x += dx * 0.06 * config.speedMult; 
                ball.y += dy * 0.06 * config.speedMult;
                if (ball.stateTimer <= 0) {
                    ball.state = 'running';
                    ball.targetX = width * 0.2 + Math.random() * width * 0.6;
                    ball.targetY = height * 0.2 + Math.random() * height * 0.6;
                }
            }
            else if (ball.state === 'caught') {
                if (ball.stateTimer <= 0) {
                    ball.state = 'escaping';
                    const angleToCenter = Math.atan2(height/2 - ball.y, width/2 - ball.x);
                    ball.angle = angleToCenter + Math.PI + (Math.random() - 0.5);
                }
            }
            else if (ball.state === 'escaping') {
                const speed = 30 * config.speedMult; 
                ball.x += Math.cos(ball.angle) * speed;
                ball.y += Math.sin(ball.angle) * speed;
                if (ball.x < -300 || ball.x > width + 300 || ball.y < -300 || ball.y > height + 300) {
                    ball.state = 'hiding'; ball.stateTimer = 80;
                }
            }
        }

        function pickNewTarget() {
            const padding = 100;
            ball.targetX = padding + Math.random() * (width - padding * 2);
            ball.targetY = padding + Math.random() * (height - padding * 2);
        }
        function goOffScreen() {
            ball.state = 'going_hide';
            const edge = Math.floor(Math.random() * 4);
            const extra = 250;
            if (edge === 0) { ball.targetX = Math.random() * width; ball.targetY = -extra; }
            else if (edge === 1) { ball.targetX = width + extra; ball.targetY = Math.random() * height; }
            else if (edge === 2) { ball.targetX = Math.random() * width; ball.targetY = height + extra; }
            else { ball.targetX = -extra; ball.targetY = Math.random() * height; }
            ball.angle = Math.atan2(ball.targetY - ball.y, ball.targetX - ball.x);
        }
        function preparePeek() {
            ball.state = 'peeking'; ball.stateTimer = 90;
            const edge = Math.floor(Math.random() * 4); const r = ball.radius;
            if (edge === 0) { 
                ball.x = Math.random()*width; ball.y = -r*3;
                ball.targetX = ball.x; ball.targetY = r*0.5; ball.angle = Math.PI/2;
            } else if (edge === 1) { 
                ball.x = width+r*3; ball.y = Math.random()*height;
                ball.targetX = width-r*0.5; ball.targetY = ball.y; ball.angle = Math.PI;
            } else if (edge === 2) { 
                ball.x = Math.random()*width; ball.y = height+r*3;
                ball.targetX = ball.x; ball.targetY = height-r*0.5; ball.angle = -Math.PI/2;
            } else { 
                ball.x = -r*3; ball.y = Math.random()*height;
                ball.targetX = r*0.5; ball.targetY = ball.y; ball.angle = 0;
            }
        }

        function draw() {
            ctx.clearRect(0, 0, width, height);
            ctx.save();
            let drawX = ball.x; let drawY = ball.y;
            if (ball.state === 'caught') {
                drawX += (Math.random() - 0.5) * 25;
                drawY += (Math.random() - 0.5) * 25;
            }
            ctx.translate(drawX, drawY); ctx.rotate(ball.angle);

            const tailSpeed = ball.state === 'caught' ? 1.0 : (ball.state === 'idle' ? 0.05 : 0.3);
            ball.tailAngle += tailSpeed;
            const tailSwing = Math.sin(ball.tailAngle) * 0.6;
            
            ctx.beginPath(); ctx.moveTo(-10 * config.sizeMult, 0);
            ctx.quadraticCurveTo(-ball.radius * 2.5, tailSwing * 25 * config.sizeMult, -ball.radius * 3.5, tailSwing * 50 * config.sizeMult);
            ctx.lineWidth = 8 * config.sizeMult; ctx.strokeStyle = config.ballColor; ctx.lineCap = 'round'; ctx.stroke();

            ctx.beginPath(); ctx.arc(0, 0, ball.radius, 0, Math.PI * 2);
            ctx.fillStyle = config.ballColor; ctx.fill();

            ball.blinkTimer--;
            if (ball.blinkTimer < 0) { ball.isBlinking = !ball.isBlinking; ball.blinkTimer = ball.isBlinking ? 8 : 100 + Math.random() * 150; }
            if (!ball.isBlinking || ball.state === 'caught') {
                const off = 9 * config.sizeMult;
                drawEye(off+1, -off, ball.state === 'caught');
                drawEye(off+1, off, ball.state === 'caught');
            }
            ctx.restore();
        }

        function drawEye(offsetX, offsetY, isScared) {
            ctx.beginPath();
            const r = (isScared ? 9 : 7) * config.sizeMult;
            ctx.arc(offsetX, offsetY, r, 0, Math.PI * 2); ctx.fillStyle = 'white'; ctx.fill();
            ctx.beginPath();
            const pupilR = (isScared ? 1.5 : 2.5) * config.sizeMult;
            ctx.arc(offsetX + 2 * config.sizeMult, offsetY, pupilR, 0, Math.PI * 2); ctx.fillStyle = '#000'; ctx.fill();
        }

        function lerpAngle(a, b, t) {
            const d = b - a;
            const da = (d + Math.PI * 3) % (Math.PI * 2) - Math.PI;
            return a + da * t;
        }
        function loop() { 
            updateBehavior(); 
            updateRunningSound();
            draw(); 
            requestAnimationFrame(loop); 
        }

        const ui = {
            btnSettings: document.getElementById('btn-settings'),
            btnLock: document.getElementById('btn-lock'),
            panel: document.getElementById('settings-panel'),
            btnClose: document.getElementById('btn-close'),
            chkSound: document.getElementById('chk-sound'),
            rangeSpeed: document.getElementById('range-speed'),
            rangeSize: document.getElementById('range-size'),
            rangeStruggle: document.getElementById('range-struggle'),
            valSpeed: document.getElementById('val-speed'),
            valSize: document.getElementById('val-size'),
            valStruggle: document.getElementById('val-struggle'),
            unlockContainer: document.getElementById('unlock-container'),
            unlockTrigger: document.getElementById('btn-unlock-trigger'),
            unlockProgressContainer: document.getElementById('unlock-progress-container'),
            unlockProgress: document.getElementById('unlock-progress')
        };

        ui.btnSettings.onclick = (e) => { e.stopPropagation(); ui.panel.style.display = 'flex'; ui.btnSettings.style.display = 'none'; };
        ui.btnClose.onclick = (e) => { e.stopPropagation(); ui.panel.style.display = 'none'; ui.btnSettings.style.display = 'flex'; };
        
        ui.chkSound.onchange = (e) => { config.enableRunningSound = e.target.checked; };
        ui.rangeSpeed.oninput = (e) => { config.speedMult = parseFloat(e.target.value); ui.valSpeed.textContent = config.speedMult+'x'; };
        ui.rangeSize.oninput = (e) => { config.sizeMult = parseFloat(e.target.value); ui.valSize.textContent = config.sizeMult+'x'; };
        ui.rangeStruggle.oninput = (e) => { config.struggleTime = parseFloat(e.target.value); ui.valStruggle.textContent = config.struggleTime+'s'; };

        ui.btnLock.onclick = (e) => {
            e.stopPropagation(); config.isLocked = true;
            try { if (document.documentElement.requestFullscreen) document.documentElement.requestFullscreen(); } catch(err) {}
            ui.panel.style.display = 'none'; ui.btnSettings.style.display = 'none'; ui.btnLock.style.display = 'none'; ui.unlockContainer.style.display = 'flex';
        };

        let unlockTimer = null; const UNLOCK_DURATION = 2000;
        function startUnlock(e) {
            e.stopPropagation(); e.preventDefault();
            ui.unlockProgressContainer.style.display = 'block'; ui.unlockProgress.style.width = '0%'; ui.unlockProgress.offsetHeight; 
            ui.unlockProgress.style.transition = `width ${UNLOCK_DURATION}ms linear`; ui.unlockProgress.style.width = '100%';
            unlockTimer = setTimeout(performUnlock, UNLOCK_DURATION);
        }
        function cancelUnlock(e) {
            if (unlockTimer) { clearTimeout(unlockTimer); unlockTimer = null; }
            ui.unlockProgress.style.transition = 'none'; ui.unlockProgress.style.width = '0%'; ui.unlockProgressContainer.style.display = 'none';
        }
        function performUnlock() {
            config.isLocked = false; if (navigator.vibrate) navigator.vibrate(50);
            ui.unlockContainer.style.display = 'none'; ui.btnSettings.style.display = 'flex'; ui.btnLock.style.display = 'flex';
            try { if (document.exitFullscreen) document.exitFullscreen(); } catch(err){}
        }

        ui.unlockTrigger.addEventListener('mousedown', startUnlock); ui.unlockTrigger.addEventListener('touchstart', startUnlock);
        ui.unlockTrigger.addEventListener('mouseup', cancelUnlock); ui.unlockTrigger.addEventListener('mouseleave', cancelUnlock);
        ui.unlockTrigger.addEventListener('touchend', cancelUnlock);
        ui.panel.addEventListener('mousedown', e => e.stopPropagation()); ui.panel.addEventListener('touchstart', e => e.stopPropagation());

        init();
    </script>
</body>
</html>